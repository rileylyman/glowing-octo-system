<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>Interacting Fluids with Rigid Bodies</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2020</h1>
<h1 align="middle">Interacting Fluids with Rigid Bodies</h1>
<h2 align="middle">Riley Lyman (SID: 3032749956)</h2>
<h2 align="middle">Peter Generao (SID: 3032631006)</h2>
<h2 align="middle">Angela Chen (SID: 3033953901)</h2>

<br><br>

<div>

    <h1 dir="ltr" style="line-height:1.38;text-align: center;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:20pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Abstract</span></h1>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In this project, we were interested in simulating the effects of a fluid on solids in a 3D scene. To this end, we implemented a 3D renderer, a fluid simulator, and the interface between these two subsystems using OpenGL. Our engine allows us to render the interactions between 3D and fluids in real-time. In addition, we have implemented a number of useful 3D rendering techniques as well as a method to render our fluids by taking 2D slices with a plane.&nbsp;</span></p>
    <h1 dir="ltr" style="line-height:1.38;text-align: center;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:20pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Technical Approach</span></h1>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In the next subsections, we will detail the implementation of our project, including the renderer, the fluid simulator, and the interface between these two components.</span></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">3D Rendering and Scene Representation</span></h2>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In order to augment our learning experience from this project, we thought it would be best to implement everything from scratch in OpenGL. Ultimately, this was a decision that would lead to more hours of work but would pay off in the end because of the greater control and understanding of our system it gave us.&nbsp;</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">The first component of our renderer is a JSON scene representation. For each scene, we create a JSON file that holds the properties of that scene. These properties include which shaders to load, which models to render, the transforms and physics properties of these models, the positions and directions of lights, etc. Our system then reads in this JSON using the help of the C++ JSON library (</span><a href="https://nlohmann.github.io/json/" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">https://nlohmann.github.io/json/</span></a><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">) loads the scene into memory.&nbsp;</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">To load shaders, we read in their source files and compile using OpenGL commands. To load lights into the scene, we simply set uniforms within these shaders which allow the lighting calculations to be done correctly. To load models is a bit more complicated. We use the Assimp asset importer library (</span><a href="https://www.assimp.org/" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">https://www.assimp.org/</span></a><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">) to load the vertices of the models into program memory. We then read these vertices into OpenGL vertex buffer objects for rendering. Because Assimp tells out the information contained in each vertex and how the vertices are laid out, we can then bind an OpenGL vertex array object to the buffer. Then, we set the attribute pointers of the vertex array object according to the layout of the vertex data, allowing our shader to read in position, texture coordinate, normal, tangent, and bitangent data from each vertex in the model. We can then use another OpenGL call along with the mesh triangle indices to draw the model.&nbsp;</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">When we read in the vertices of each model from Assimp, we keep track of the minimum and maximum x-, y-, and z-position values for each vertex. This allows us to calculate the bounding box for each model, which will be used in our physics calculations. After we have loaded in the model and have its bounding box, we create a new physics object using the Bullet3 (</span><a href="https://github.com/bulletphysics/bullet3" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">https://github.com/bulletphysics/bullet3</span></a><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">) physics library. We supply the physics library with the initial transformation of the bounding box (which we read in from the scene JSON) and from then on we allow the physics library to update the transform of the bounding box based on the forces we apply to it. We then apply these same transforms to the models in the vertex shader, thus synchronizing our scene with the physics library&rsquo;s bounding representation of our world.&nbsp;</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In addition to the core features of the renderer listed above, we also added many peripheral features that either improved the aesthetics of our rendered scenes or provided additional functionality necessary for debugging. In terms of aesthetic add-ons, we implemented skyboxes, bump mapping, antialiasing, physically based shaders, and high dynamic range tone mapping. In terms of features necessary for debugging, the most important were our debug GUI and the fluid debug renderer. We implemented a GUI in order to control aspects of our renderer and simulation using the ImGUI library (</span><a href="https://github.com/ocornut/imgui" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">https://github.com/ocornut/imgui</span></a><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">). ImGUI allowed us to quickly mock-up debug interfaces without the hassle of integrating UI overlays into our renderer. The fluid debug renderer was important as it gave us a debug view of how our fluid was behaving at any given point in time. Its implementation will be described in a later section.</span></p>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Real Time Fluid Simulation</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Physics:</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Our fluid simulation relies on a discretized version of the Navier Stokes equation. Let&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">u</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;represent velocity,&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">nu</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;represent viscousity,&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">d</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;represents density,&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">p</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;represent pressure, and&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">f</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;represent force.</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image10.png"></div>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Credits to Srinivasa Narasimhan for the picture of the Navier-Stokes equation in their &ldquo;Modeling, Simulating and Rendering Fluids&rdquo; slides</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">From left to right, the four terms used in calculating the local acceleration of the fluid in this equation are the advection term, the diffusion term, the pressure projection term, and the external forces term.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Advection:</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image9.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Advection is the process in which quantities within the fluid are moved around (or&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">advected</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">) by the local velocity field. Intuitively, this represents the physical observable associated with a fluid particle moving with the particle as the particle is pushed around by the rest of the fluid. For example, scalar fields like temperature or vector fields like color can be advected by the velocity field. The term in the Navier Stokes equation represents advection of the velocity field (i.e. particles carrying a certain velocity are pushed to a new location).</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Diffusion:</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image8.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Diffusion is the process in which quantities tend to &ldquo;average&rdquo; themselves out over a local region as time passes. This is related to heat diffusing through a liquid, or even velocity averaging out as particles in the fluid bump into each other. For our simulation, we assume our fluids are&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">inviscid</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;so we don&rsquo;t have to calculate this term directly.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Our simulation accounts for small amounts of diffusion due to the inherent smoothing involved in our discrete formulation of the Navier Stokes equation.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Pressure Projection:</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image7.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">One of the key properties of a fluid is that it is&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">incompressible</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;or&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">divergence-free</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp; (i.e. fluids do not flow into or out of points, so there are no sources or sinks). The divergence of the pressure encodes this, so subtracting this yields us a divergence free velocity field in the next time step.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Force Application</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image6.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">This is the application of other forces not directly related to the fluid. This includes forces such as buoyancy, gravity, and external forces.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Implementation</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Our implementation of the fluid simulator uses 3D textures and compute shaders to both represent and evolve our fluid solely in the GPU. We follow the outlined process/explanation in (GPU Gems 1)&rsquo;s 2D fluid simulation to simulate our 3D fluid. Thus, we advect, apply forces, and project to the divergence-free component.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">For advection, we referenced two schemes cited in (GPU Gems 3): the first is the Semi-Lagrangian scheme which takes the current velocity at a given position, and samples the particle which&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">would</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;arrive in that position given the assumed velocity; the second is the McCormack scheme which takes an arbitrary advection scheme and attempts to remove errors associated with the numerical approximation by seeing what a single advection step would imply about the previous advection step.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Semi-Lagrangian:</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image5.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Credits to GPU Gems, Chapter 38 for the Semi-Lagrangian equation. q represents our advected quantity, u represents our velocity field.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">McCormack:</span></p>
    <div align="middle"><img src="images/image4.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Credits to GPU Gems 3, Chapter 30 for the equation. &Phi;^n represents our advected quantity, A represents our Advection scheme, and A^R represents our Advection scheme run backwards.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">The Semi-Lagrangian scheme introduces small amounts of diffusion as a byproduct when we sample, while the McCormack scheme attempts to correct for this.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">For force application, we computed both gravity and the buoyant force acting on each particle, and added them to our unprojected velocity field.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Buoyancy:</span></p>
    <div align="middle"><img src="images/image3.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;text-align: center;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Credits to GPU Gems 3, Chapter 30 for the buoyancy equation</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">To calculate for pressure, we solve a&nbsp;</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Poisson Equation</span><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;listed in (GPU Gems 1) via an iterative numerical method known as Jacobi iterations. This implementation/explanation is far too technical to be included in this paper, so we defer to (GPU Gems 3) for the 3D version of Jacobi Iterations with boundary conditions, and (GPU Gems 1) for the formulation of the Poisson Equation.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Solving a Poisson Equation via Jacobi iterations requires multiple shader calls, and since it converges slowly, we need at least ~20 to get stable/convincing results.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">The reason why we only model inviscid fluids is because we would need to solve a Poisson Equation for the diffusion term, which is unnecessary computational overhead for an effect &nbsp;which is captured in using the Semi-Lagrangian advection scheme.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Boundary Conditions</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">The only boundary condition which we need to explicitly enforce is the &ldquo;free-slip&rdquo; condition, which states that fluid can not flow into or out of the boundary of a surface. To enforce this, we ensure that the velocity of a fluid cell next to solid cells have the same normal-component of the velocity of the solid cell relative to the surface normal.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">We apply this explicitly at the end of our velocity calculations, and implicitly when solving for pressure.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Additionally, due to the finite nature of our simulation&rsquo;s bounding box, we enforce that all cells on the boundary of our fluid simulation grid are solid cells to avoid undefined behavior at the (literal) boundaries which would propagate through the fluid.</span></p>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Fluid Debug Renderer &nbsp;</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In order to visualize our fluids for debugging purposes, we needed a way to view our 3D fluid textures on our 2D computer screens. The solution we came up with was slicing through the fluid with a plane that is at a constant offset from the camera. We then project the fluid values down onto this plane as colors so that we can visualize the properties of the fluid.</span></p>
    <p><br></p>
    <div align="middle"><img src="images/image2.png"></div>
    <p><br></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Shown above is an example of this fluid debug plane. We implemented this debug view as follows. Because we want the debug plane to always be at a fixed location relative to the camera, we specify the coordinates of the plane in view-space. This also saves us from having to calculate the updated position of the plane at every timestep. Now that we have the plane in view space, we need the look-at transformation of the camera to transform the 3D textures representing the fluid into view space as well. After we have both the plane and the fluid in view-space, each fragment of the debug plane falls within a cell of the 3D fluid texture.&nbsp;</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Sampling the fluid at each fragment location within the plane yields a 3D vector or scalar which could be directly represented on the plane as an RGB value. However, this representation of the fluid can turn out to be very unintuitive for debugging purposes. The representation we chose projects the vector onto our debug plane and then plots an HSV color value based on the angle and magnitude of this projected value in polar coordinates. If the projected vector v has angle theta and magnitude r, then we plot the HSV value (theta, 1.0, r). This means that the direction the vector is pointing influences the value, and the magnitude of the vector influences the saturation, leading to an easily interpretable debug color value. The final result is a debug representation of our fluid that is intuitive to reason about and immensely helpful for solving problems within our simulator since we could see &ldquo;inside&rdquo; of the fluid as opposed to traditional 3D methods which may be more difficult to see.&nbsp;</span></p>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Scene Voxelization</span></h2>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Because all of our fluid simulation is done with 3D textures in compute shaders on the GPU, we cannot directly interact with our 3D scene representation as-is. In order to factor the arrangement of our 3D world into our fluid calculations, we need to generate another 3D texture which represents where our solids are in the scene. The fluid can then use this information to calculate the boundary conditions in the fluid given the 3D bodies in our world.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">The act of transforming our 3D scene into a 3D texture is called voxelization. We voxelize the bounding boxes of our meshes instead of the meshes themselves for performance and simplicity reasons, and because our physics engine operates on bounding boxes and not the meshes themselves.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Every fluid has an offset from origin and the dimensions it takes up in the x,y, and z directions. We apply the inverse of this transformation to the world-space bounding box in order to get the bounding box into fluid-space. Then, we loop through each cell within the 3D texture representing the fluid and test whether or not the bounding box intersects with that cell, coloring each cell based on whether a solid is present or not. The resulting voxelized 3D texture is then passed to the fluid simulation pipeline to be used in further computations.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">One we have our voxelized information, we simply supply this information in masks to the shaders. Thus, the shaders will be able to differentiate fluid cells from solid cells when enforcing the free-slip condition and sampling values which correspond to solid cells.</span></p>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Pressure Read-Back</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">We need a way of reading the 3D texture corresponding to pressure back from the GPU to the CPU, where we can use the pressure field to determine force. The naive approach would be to synchronously request the data from the GPU, wait until the data is transferred, and then proceed with computation. In our real-time setting, this approach was far too slow, killing our framerate. Memory traffic from the GPU to the CPU is extremely high in our setting, meaning that the GPU lacks the bandwidth the transfer the necessary data to the CPU in a timely manner. In order to get around this, we need to read from the GPU asynchronously.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">OpenGL exposes a method of accomplishing this with Pixel Buffer Objects. Pixel Buffer Objects allow data to be asynchronously read to a CPU buffer using DMA, freeing us up to do other work while waiting for the pressure data. We can then request a pointer to the transferred data, at which point the CPU will stall until the requested data is present. Right away, it is clear that using only one Pixel Buffer would yield similar performance to the synchronous case due to this stalling. The true benefit is when we use multiple.</span></p>
    <p><br></p>
    <p><br></p>
    <div align="middle"><img src="images/image1.png"></div>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Shown above is an example of how Pixel Buffers can be used to improve performance. At iteration n, the CPU request that PBO 1 be filled with data while reading from PBO 2, which has already been filled with data. Then, at iteration n+1, the CPU asks for PBO 2 to be filled with data and reads from PBO 1, which is now completely filled with the data requested on iteration n. We use this scheme with three Pixel Buffers in our system, meaning that at frame n, we are reading from pressure values that were generated on frame n-2. This allows us to read pressure data back from the GPU almost instantly, solving our bottleneck and improving performance immensely.&nbsp;</span></p>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Force Integration</span></h2>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Most of the interactions that a fluid has on solid can be represented by three forces: lift, drag, and buoyancy. These three forces are a direct result of pressure, so once we finish reading our pressure values back to the CPU, we sample from the grid values and approximate the forces acting on the surfaces of the bounding box. The integral of pressure is force, so we perform Monte Carlo integration to yield our resulting forces on the object.</span></p>
    <h1 dir="ltr" style="line-height:1.38;text-align: center;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:20pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Lessons Learned</span></h1>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Working on this project, we encountered many problems that set us back in some way or another. In solving these challenges as they arose, we learned many valuable lessons about graphics programming and simulation that we will carry with us in our future endeavors.</span></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">OpenGL Extension Support</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">A key fact about OpenGL is that it is implemented in proprietary drivers which can vary across graphics card models and manufacturers. Each GPU has drivers that support different versions and extensions of OpenGL. Therefore, something that may need to be enabled as an extension for one graphics card could be enabled by default for another. We came up against this when attempting to load from and store to images in OpenGL compute shaders. On one of our machines, loading and storing were working perfectly while for another group member the operations failed. Finally, we discovered that for some driver implementations, the ARB_image_load_store extension has to be explicitly enabled for the operations to work. Now that we have fixed this problem, we have a better understanding of how to tackle similar issues in the future when working with OpenGL.&nbsp;</span></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Rotating the bounding box for voxelization</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Another problem we came up against is one fundamental to graphics: choosing the correct coordinate space can make all the difference for how difficult a problem is. Originally, we were transforming the mesh bounding box into fluid space in order to do voxelization. Because we defined the mesh bounding box by its two extreme values (i.e. the position of the bottom left corner and the position of the top right corner), transforming these corners of the box into the fluid could end up defining a different bounding box altogether. For example, you could imagine rotating the bounding box such that its two extreme values are on the same plane, which would give the bounding box zero volume. To combat against this, instead of transforming the box into fluid space, we found it vastly easier to do the inverse transform from the fluid into local mesh space. This meant that we no longer had to worry about these problems, and could easily voxelize the mesh bounding box. Coming away from this problem, we now know always to analyze the coordinate spaces we are working in to see if they are appropriate for solving the given problem.</span></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Texture unit collisions</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In our representation, we were relying on a struct that we created to handle texture/image unit binding; however, we assumed that the units for a specified texture never changed. This turned out to be a very bad assumption when we began to invoke our shaders as we had more textures for our physics simulation than available image units, so we had naming-collisions (i.e. only one of two textures would be used in a shader call).</span></p>
    <h2 dir="ltr" style="line-height:1.38;text-align: center;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Masks not writing due to not dispatching compute shader</span></h2>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">In one portion of our code, we learned the importance of dispatching shaders immediately after we want to use them. In our code, when we were reading our voxelization information, we were rebinding our image/texture units multiple times before invoking the shader which clears and rewrites the mask. This caused a solid to leave a &ldquo;streak&rdquo; of solid grid cells in our fluid simulation as our solid mask was never clearing.</span></p>
    <h1 dir="ltr" style="line-height:1.38;text-align: center;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:20pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Results</span></h1>
    <h2 dir="ltr" style="line-height:1.38;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Voxelization of Our Scene</span></h2>
    <div align="middle"><img src="images/voxel.gif"></div>
    <h2 dir="ltr" style="line-height:1.38;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Simulating an External Force Acting on Our Fluid</span></h2>
    <div align="middle"><img src="images/fluid.gif"></div>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Rigid Bodies Affecting the Fluid</span></h2>
    <div align="middle"><img src="images/solid.gif"></div>
    <p><br></p>
    <h2 dir="ltr" style="line-height:1.38;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Multiple Rigid Bodies Falling through our Fluid</span></h2>
    <div align="middle"><img src="images/multisecond.gif"></div>
    <div align="middle"><img src="images/multithird.gif"></div>
    <h2 dir="ltr" style="line-height:1.38;margin-top:18pt;margin-bottom:6pt;"><span style="font-size:16pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Adding a Strong Jet Stream to the Bottom of the Fluid</span></h2>
    <div align="middle"><img src="images/pressure.gif"></div>
    <p><br></p>
    <h1 dir="ltr" style="line-height:1.38;text-align: center;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:20pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">References</span></h1>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><a href="https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-30-real-time-simulation-and-rendering-3d-fluids" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Chapter 30. Real-Time Simulation and Rendering of 3D Fluids | NVIDIA Developer</span></a></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><a href="http://www.cs.cmu.edu/afs/cs/academic/class/16823-s16/www/pdfs/appearance-modeling-22.pdf" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">http://www.cs.cmu.edu/afs/cs/academic/class/16823-s16/www/pdfs/appearance-modeling-22.pdf</span></a></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><a href="https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">GPU Gems - Chapter 38. Fast Fluid Dynamics Simulation on the GPU</span></a></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;"></span><a href="https://www.songho.ca/opengl/gl_pbo.html" style="text-decoration:none;"><span style="font-size:11pt;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;-webkit-text-decoration-skip:none;text-decoration-skip-ink:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">https://www.songho.ca/opengl/gl_pbo.html</span></a><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">&nbsp;</span></p>
    <h1 dir="ltr" style="line-height:1.38;text-align: center;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:20pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Contributions</span></h1>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Riley handled writing the 3D renderer in OpenGL, the ImGUI debug layer, the scene JSON representation, the fluid debug plane, the voxelization system, and the reading back of pressure via Pixel Buffer Objects.</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Peter handled most aspects of fluid simulation implementation including modeling the fluid, writing in support for OpenGL compute shaders, writing the compute shaders for the fluid, outputting forces on our objects via the pressure field, and integrating our 3D scene voxelization with the fluid simulation itself.&nbsp;</span></p>
    <p><br></p>
    <p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:11pt;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre;white-space:pre-wrap;">Angela helped with 3D scene creation, 3D modeling of assets, researching fluid simulation techniques, finding resources for our implementation of fluids, and debugging our system.&nbsp;</span></p>
    
</div>


</body>
</html>
