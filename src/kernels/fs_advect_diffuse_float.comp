#version 430 core

// Built-in Variables
// in uvec3 gl_NumWorkGroups;
// in uvec3 gl_WorkGroupID;
// in uvec3 gl_LocalInvocationID;
// in uvec3 gl_GlobalInvocationID;
// in uint  gl_LocalInvocationIndex;

layout(local_size_x = 1, local_size_y = 1) in;

// ASSUMES that dimensions of velocity field and advected quantity matches gl_NumWorkGroups

uniform sampler3D vel_sampler;      // velocity field
uniform sampler3D target_sampler;   // quantity to be advected (float)
uniform image3D target_buffer;      // buffer to store advected quantities (float)

uniform sampler3D solid_sampler;    // quantity related to solid
uniform usampler3D solid_mask;      // stores solid mask

uniform vec3 scale;                 // dimensions of a cell in x,y,z

uniform float dt;                   // delta time

bool isSolidCell(vec3 index) {
    vec3 zero = vec3(0.0, 0.0, 0.0);
    vec3 one = vec3(1.0, 1.0, 1.0);
    return texture(solid_sampler, clamp(cell2texture(index), zero, one)).r > 0.0;
}

vec3 cell2texture(vec3 index) {
    return index / vec3(float(gl_NumWorkGroups.x), float(gl_NumWorkGroups.y), float(gl_NumWorkGroups.z));
}

void main() {
    // get position of cell in index-space
    vec3 pos = vec3(float(gl_WorkGroupID.x), float(gl_WorkGroupID.y), float(gl_WorkGroupID.z));
    pos = (pos + vec3(0.5, 0.5, 0.5));

    // sample velocity at cell
    vec3 vel = texture(vel_sampler, cell2texture(pos)).rgb;
    
    // advect only if this isn't a solid cell
    if (!isSolidCell(pos)) {
        // get position from index (index-space -> world)
        pos *= scale;

        // go back in time for quantities that advect to this pos
        pos -= dt * vel;

        // (world -> index-space)
        pos /= scale;
    }

    // sample advected quantity
    vec3 zero = vec3(0.0, 0.0, 0.0);
    vec3 one = vec3(1.0, 1.0, 1.0);
    vec4 advected_sample = texture(target_sampler, clamp(cell2texture(pos), zero, one));
    
    // write to buffer
    imageStore(target_buffer, index, advected_sample);
}